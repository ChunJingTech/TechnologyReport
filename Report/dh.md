
# DH 是基于离散对数问题

## DH 基本原理

```
a ^ m = k mod n
```

知道 a, m, n 求 k 很容易
但是知道其他的求 m 很难


## DH 用于 A 和 B 端进行密钥交换

n 的本原根 g，就是 a ^ m = k mod n 里面的 本原根 g，跟 n 有关

按照 SM2 的要求，如果是整数域的 DH，n 不得小于 1024 bit

g 和 n（大素数）都是已经生成好的（根证书），双方都知道，攻击者也知道

```
g^1, g^2 …………mod n，\\ 可以遍历 1~n-1 : 集合 {g^1 mod n，g^2 mod n，……，g^n-1 mod n}=集合{1,2，……n-1}
```

现在： 
A 生成一个随机数 a（小于 n），计算 Xa = g^a mod n     
B 生成一个随机数 b，计算 Xb = g^b mod n

**根据定理**：
```
a1 > n，存在 a2 < n 使得 
g^a1 mod n = g^a2 mod n 且 a^p = a mod p, p 为质数
```

然后 A 把 Xa 传给 B，B 把 Xb 传给 A

A 计算
``` 
key = Xb^a mod n = (g^b)^a mod n = g^(a*b)mod n
```

B 计算 
```
key = Xa^b mod n = (g^a)^b mod n = g^(b*a)mod n
```

两边用key当做密钥就行了

攻击者不能通过 Xa 和 Xb 计算 a 和 b 或者 key


## 不能抵抗中间人攻击

防中间人攻击: 服务端私钥签名...客户端公钥验证..如果私钥跪了..那么客户端通过更新接口获取新的公钥

备注: 去摸的快速算法叫蒙哥马利算法


## 关键问题

- 计算大素数 n  
         
- 计算本原根 g



私钥签名..公钥验证
公钥加密..私钥解密






